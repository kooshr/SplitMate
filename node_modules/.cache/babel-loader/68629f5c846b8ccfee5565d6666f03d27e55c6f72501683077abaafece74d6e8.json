{"ast":null,"code":"const createJob = require('./createJob');\nconst {\n  log\n} = require('./utils/log');\nconst getId = require('./utils/getId');\nlet schedulerCounter = 0;\nmodule.exports = () => {\n  const id = getId('Scheduler', schedulerCounter);\n  const workers = {};\n  const runningWorkers = {};\n  let jobQueue = [];\n  schedulerCounter += 1;\n  const getQueueLen = () => jobQueue.length;\n  const getNumWorkers = () => Object.keys(workers).length;\n  const dequeue = () => {\n    if (jobQueue.length !== 0) {\n      const wIds = Object.keys(workers);\n      for (let i = 0; i < wIds.length; i += 1) {\n        if (typeof runningWorkers[wIds[i]] === 'undefined') {\n          jobQueue[0](workers[wIds[i]]);\n          break;\n        }\n      }\n    }\n  };\n  const queue = (action, payload) => new Promise((resolve, reject) => {\n    const job = createJob({\n      action,\n      payload\n    });\n    jobQueue.push(async w => {\n      jobQueue.shift();\n      runningWorkers[w.id] = job;\n      try {\n        resolve(await w[action].apply(this, [...payload, job.id]));\n      } catch (err) {\n        reject(err);\n      } finally {\n        delete runningWorkers[w.id];\n        dequeue();\n      }\n    });\n    log(\"[\".concat(id, \"]: Add \").concat(job.id, \" to JobQueue\"));\n    log(\"[\".concat(id, \"]: JobQueue length=\").concat(jobQueue.length));\n    dequeue();\n  });\n  const addWorker = w => {\n    workers[w.id] = w;\n    log(\"[\".concat(id, \"]: Add \").concat(w.id));\n    log(\"[\".concat(id, \"]: Number of workers=\").concat(getNumWorkers()));\n    dequeue();\n    return w.id;\n  };\n  const addJob = async function (action) {\n    if (getNumWorkers() === 0) {\n      throw Error(\"[\".concat(id, \"]: You need to have at least one worker before adding jobs\"));\n    }\n    for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n    return queue(action, payload);\n  };\n  const terminate = async () => {\n    Object.keys(workers).forEach(async wid => {\n      await workers[wid].terminate();\n    });\n    jobQueue = [];\n  };\n  return {\n    addWorker,\n    addJob,\n    terminate,\n    getQueueLen,\n    getNumWorkers\n  };\n};","map":{"version":3,"names":["createJob","require","log","getId","schedulerCounter","module","exports","id","workers","runningWorkers","jobQueue","getQueueLen","length","getNumWorkers","Object","keys","dequeue","wIds","i","queue","action","payload","Promise","resolve","reject","job","push","w","shift","apply","err","concat","addWorker","addJob","Error","_len","arguments","Array","_key","terminate","forEach","wid"],"sources":["/Users/kaush/Desktop/SplitMate/node_modules/tesseract.js/src/createScheduler.js"],"sourcesContent":["const createJob = require('./createJob');\nconst { log } = require('./utils/log');\nconst getId = require('./utils/getId');\n\nlet schedulerCounter = 0;\n\nmodule.exports = () => {\n  const id = getId('Scheduler', schedulerCounter);\n  const workers = {};\n  const runningWorkers = {};\n  let jobQueue = [];\n\n  schedulerCounter += 1;\n\n  const getQueueLen = () => jobQueue.length;\n  const getNumWorkers = () => Object.keys(workers).length;\n\n  const dequeue = () => {\n    if (jobQueue.length !== 0) {\n      const wIds = Object.keys(workers);\n      for (let i = 0; i < wIds.length; i += 1) {\n        if (typeof runningWorkers[wIds[i]] === 'undefined') {\n          jobQueue[0](workers[wIds[i]]);\n          break;\n        }\n      }\n    }\n  };\n\n  const queue = (action, payload) => (\n    new Promise((resolve, reject) => {\n      const job = createJob({ action, payload });\n      jobQueue.push(async (w) => {\n        jobQueue.shift();\n        runningWorkers[w.id] = job;\n        try {\n          resolve(await w[action].apply(this, [...payload, job.id]));\n        } catch (err) {\n          reject(err);\n        } finally {\n          delete runningWorkers[w.id];\n          dequeue();\n        }\n      });\n      log(`[${id}]: Add ${job.id} to JobQueue`);\n      log(`[${id}]: JobQueue length=${jobQueue.length}`);\n      dequeue();\n    })\n  );\n\n  const addWorker = (w) => {\n    workers[w.id] = w;\n    log(`[${id}]: Add ${w.id}`);\n    log(`[${id}]: Number of workers=${getNumWorkers()}`);\n    dequeue();\n    return w.id;\n  };\n\n  const addJob = async (action, ...payload) => {\n    if (getNumWorkers() === 0) {\n      throw Error(`[${id}]: You need to have at least one worker before adding jobs`);\n    }\n    return queue(action, payload);\n  };\n\n  const terminate = async () => {\n    Object.keys(workers).forEach(async (wid) => {\n      await workers[wid].terminate();\n    });\n    jobQueue = [];\n  };\n\n  return {\n    addWorker,\n    addJob,\n    terminate,\n    getQueueLen,\n    getNumWorkers,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}